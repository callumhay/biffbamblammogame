float Script : STANDARDSGLOBAL <
    string UIWidget = "none";
    string ScriptClass = "object";
    string ScriptOrder = "standard";
    string ScriptOutput = "color";
    string Script = "Technique=Main;";
> = 0.8;

//// UN-TWEAKABLES - AUTOMATICALLY-TRACKED TRANSFORMS ////////////////

float4x4 WvpXf : WorldViewProjection < string UIWidget="None"; >;
float4x4 WorldXf : World < string UIWidget="None"; >;
float4x4 ViewIXf : ViewInverse < string UIWidget="None"; >;

float Timer : TIME <
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 4.0;
    float UIStep = 0.01;
    string UIName =  "Timer";
> = 0;

float Scale <
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 4.0;
    float UIStep = 0.1;
    string UIName =  "Scale";
> = 1;

float Freq <
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 10.0;
    float UIStep = 0.1;
    string UIName =  "Frequency";
> = 1;

// Line points (origin and end) in world-space
float3 LinePoint1 <
    string UIName =  "LinePoint 1";
> = {0.0f,-10.0f,0.0f};

float3 LinePoint2 <
    string UIName =  "LinePoint 2";
> = {0.0f,10.0f,0.0f};

float Radius <
	string UIName =  "Radius";
	string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 10.0;
    float UIStep = 0.1;
> = {1.0f};

float3 BeamColour <
    string UIName =  "Beam Colour";
    string UIWidget = "Color";
> = {1.0, 1.0, 1.0};

texture NoiseTexture  <
    string ResourceName = "noiseL8_32x32x32.dds";
    string UIName =  "Noise Texture";
    string ResourceType = "3D";
>;

sampler3D NoiseSampler = sampler_state {
    Texture = <NoiseTexture>;
    MinFilter = LinearMipMapLinear;
    MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Repeat;
    WrapR = Repeat;
    
}; 

// Data from application vertex buffer
struct appdata {
    float3 Position	: POSITION;
    float4 Normal	: NORMAL;
};

// Data passed from vertex shader to pixel shader
struct vertexOutput {
    float4 HPosition  : POSITION;
    float3 WorldPos	  : TEXCOORD0;
	float3 WorldView  : TEXCOORD1;
};

// Vertex Shading

vertexOutput laserbeam_vs(appdata IN) {
    vertexOutput OUT = (vertexOutput)0;

    float4 Po = float4(IN.Position.xyz,1);
	float3 Pw = mul(WorldXf,Po).xyz;
	
    OUT.WorldPos = Pw;
    OUT.WorldView = normalize(float3(ViewIXf[0].w,ViewIXf[1].w,ViewIXf[2].w) - Pw);
	OUT.HPosition = mul(WvpXf,Po);
    return OUT;
}

// Pixel Shading

float4 laserbeam_ps(vertexOutput IN) : COLOR {
	float3 nWorldView = normalize(IN.WorldView);
	
	// Figure out the distance between the current fragment and the
	// center of the beam defined by LinePoint1, LinePoint2
	float3 lineVec      = LinePoint2 - LinePoint1;
	float3 nLineVec     = normalize(lineVec);
	float lineVecLength = length(lineVec);
	
	// Do some ray casting into the beam - sample based on how close to the
	// center of the beam we are (closer the stronger the beam colour)
	float volumeAccumulateTotal = 0.0f;
	const int NUM_STEPS = 16;
	float invNumSteps = 1.0 / (float)NUM_STEPS;
	float stepIncrement = Radius * invNumSteps;
	float3 startPoint = IN.WorldPos - (1.414213562 * Radius - Radius) * nWorldView;
	
	for (int i = 0; i < NUM_STEPS; i++) {
		float3 currWorldPos = startPoint - (float)i * stepIncrement * nWorldView;
		float3 fragToLineVec = currWorldPos - LinePoint1;
		float distFromFragToLine = length(cross(lineVec, fragToLineVec)) / lineVecLength;
		float invDist = Radius - distFromFragToLine;
		volumeAccumulateTotal = volumeAccumulateTotal + lerp(0, invNumSteps, invDist);
	}
	
	float3 sampleCoord = IN.WorldPos.xyz - (Freq * Timer.xxx);
	float4 texVal = tex3D(NoiseSampler, Scale * sampleCoord);
    float totalTexVal = 8.0 * (abs(texVal.x - 0.25)  + abs(texVal.y - 0.125) + 
                               abs(texVal.z - 0.0625) + abs(texVal.w - 0.03125));
							   
	volumeAccumulateTotal = clamp(volumeAccumulateTotal, 0, 1);
	float3 totalColour = clamp(texVal.x * volumeAccumulateTotal.xxx + BeamColour, 0, 1);
	
    return float4(totalColour, volumeAccumulateTotal.x);
}

///// TECHNIQUES /////////////////////////////

technique Main < string Script = "Pass=p0;"; > {
    pass p0 < string Script = "Draw=geometry;"; > {
		
        VertexProgram = compile arbvp1 laserbeam_vs();
		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		BlendEnable = true;
		BlendFunc = int2(SrcAlpha, OneMinusSrcAlpha);
		BlendEquation = FuncAdd;
		DepthFunc = LEqual;
        FragmentProgram = compile arbfp1 laserbeam_ps();	
    }
}