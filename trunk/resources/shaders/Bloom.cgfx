/**
 * Bloom.cgfx
 * (cc) Callum Hay, 2013
 *
 * Apply a multi-pass luminance selection and blur to a fullscreen rendering.
 */


float HighlightThreshold <
    string UIName = "Highlight Threshold";
    string UIWidget = "slider";
    float UIMin = 0.0f;
    float UIMax = 1.0f;
    float UIStep = 0.1f;
> = 0.9f;

float SceneIntensity <
    string UIName = "Scene Intensity";
    string UIWidget = "slider";
    float UIMin = 0.0f;
    float UIMax = 2.0f;
    float UIStep = 0.1f;
> = 0.5f;

float GlowIntensity <
    string UIName = "Glow Intensity";
    string UIWidget = "slider";
    float UIMin = 0.0f;
    float UIMax = 2.0f;
    float UIStep = 0.1f;
> = 0.5f;

float HighlightIntensity <
    string UIName = "Highlight intensity";
    string UIWidget = "slider";
    float UIMin = 0.0f;
    float UIMax = 10.0f;
    float UIStep = 0.1f;
> = 0.5f;

float SceneWidth <
    string UIWidget = "slider";
    float UIMin = 1;
    float UIMax = 1680;
    float UIStep = 1;
    string UIName =  "Width";
> = 1024.0f;

float SceneHeight <
    string UIWidget = "slider";
    float UIMin = 1;
    float UIMax = 1050;
    float UIStep = 1;
    string UIName =  "Height";
> = 768.0f;

texture SceneTex <
    string ResourceName = "lasers.jpg";
    string UIName = "Scene Texture";
    string ResourceType = "2D";
>;
sampler2D SceneSampler = sampler_state {
    Texture = <SceneTex>;   
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
};

// Downsample blur images
texture BrightDownsampleTex <
    string ResourceName = "lasers.jpg";
    string UIName = "Bright Downsample Texture";
    string ResourceType = "2D";
>;
sampler2D BrightDownsampleLvl2Sampler = sampler_state {
    Texture = <BrightDownsampleTex>;    
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
    MinMipLevel = 2;
    MaxMipLevel = 2;
};
sampler2D BrightDownsampleLvl3Sampler = sampler_state {
    Texture = <BrightDownsampleTex>;    
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
    MinMipLevel = 3;
    MaxMipLevel = 3;
};
sampler2D BrightDownsampleLvl4Sampler = sampler_state {
    Texture = <BrightDownsampleTex>;    
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
    MinMipLevel = 4;
    MaxMipLevel = 4;
};

// Composite blur images for the final composition of the bloom
sampler2D BrightCompositeLvl2Sampler = sampler_state {
    Texture = <BrightDownsampleTex>;    
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
};
sampler2D BrightCompositeLvl3Sampler = sampler_state {
    Texture = <BrightDownsampleTex>;    
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
};
sampler2D BrightCompositeLvl4Sampler = sampler_state {
    Texture = <BrightDownsampleTex>;    
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
};

const half BlurWeights[5] = {
    0.0625,
    0.25,
    0.375,
    0.25,
    0.0625,
};

half luminance(half3 c) {
    return dot(c, float3(0.3f, 0.59f, 0.11f));
}

// this function should be baked into a texture lookup for performance
half filter_highlights(half3 c, uniform float threshold) {
    return smoothstep(threshold, 1.0f, luminance(c.rgb));
}

half4 bloomfilter_PS(float2 UV : TEXCOORD0) : COLOR {
    half3 sampleColour = tex2D(SceneSampler, UV).rgb;
    return half4(sampleColour, filter_highlights(sampleColour, HighlightThreshold));
}

half4 blur_rows_PS(float2 UV : TEXCOORD0, uniform sampler2D BloomSampler) : COLOR {
    half tapUV = 1.0f / SceneHeight;
    half4 total = BlurWeights[2] * tex2D(BloomSampler, UV);
    total += BlurWeights[1] * tex2D(BloomSampler, UV + half2(tapUV, 0));
    total += BlurWeights[3] * tex2D(BloomSampler, UV + half2(-tapUV, 0));
    total += BlurWeights[0] * tex2D(BloomSampler, UV + half2(2*tapUV, 0));
    total += BlurWeights[4] * tex2D(BloomSampler, UV + half2(-2*tapUV, 0));
    return total;
}

half4 blur_cols_PS(float2 UV : TEXCOORD0, uniform sampler2D BloomSampler) : COLOR {
    half tapUV = 1.0f / SceneWidth;
    half4 total = BlurWeights[2] * tex2D(BloomSampler, UV);
    total += BlurWeights[1] * tex2D(BloomSampler, UV + half2(0, tapUV));
    total += BlurWeights[3] * tex2D(BloomSampler, UV + half2(0, -tapUV));
    total += BlurWeights[0] * tex2D(BloomSampler, UV + half2(0, 2*tapUV));
    total += BlurWeights[4] * tex2D(BloomSampler, UV + half2(0, -2*tapUV));
    return total;
}

float4 composite_bloom_PS(float2 UV : TEXCOORD0) : COLOR {   
    
    float4 origScene = tex2D(SceneSampler, UV);
    
    float4 blurLvl2 = tex2D(BrightCompositeLvl2Sampler, UV);
    float4 blurLvl4 = tex2D(BrightCompositeLvl4Sampler, UV);
    
    float4 blurTotal = clamp(blurLvl4, 0, 1);
    
    return float4(SceneIntensity*origScene.rgb + GlowIntensity*blurTotal.rgb + HighlightIntensity*blurTotal.aaa, 1);
}  

technique BloomFilter {
    pass filter {
        BlendEnable = true;
        BlendFunc = int2(SrcAlpha, OneMinusSrcAlpha); 
        FragmentProgram = compile arbfp1 bloomfilter_PS();
    }
}

technique BrightDownsampleBlur2 {
    pass blurRows2 {
        FragmentProgram = compile arbfp1 blur_rows_PS(BrightDownsampleLvl2Sampler);
    }
    pass blurCols2 {
        FragmentProgram = compile arbfp1 blur_cols_PS(BrightDownsampleLvl2Sampler);  
    }   
}

technique BrightDownsampleBlur3 {
    pass blurRows3 {
        FragmentProgram = compile arbfp1 blur_rows_PS(BrightDownsampleLvl3Sampler);
    }
    pass blurCols3 {
        FragmentProgram = compile arbfp1 blur_cols_PS(BrightDownsampleLvl3Sampler);  
    }   
}

technique BrightDownsampleBlur4 {
    pass blurRows4 {
        FragmentProgram = compile arbfp1 blur_rows_PS(BrightDownsampleLvl4Sampler);
    }
    pass blurCols4 {
        FragmentProgram = compile arbfp1 blur_cols_PS(BrightDownsampleLvl4Sampler);  
    }
}

technique CompositeBloom {
    pass bloomComposite {
        BlendEnable = true;
        BlendFunc = int2(SrcAlpha, OneMinusSrcAlpha); 
        FragmentProgram = compile arbfp1 composite_bloom_PS();  
    }
}